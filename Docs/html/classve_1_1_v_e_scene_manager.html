<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vienna Vulkan Engine: ve::VESceneManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vienna Vulkan Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceve.html">ve</a></li><li class="navelem"><a class="el" href="classve_1_1_v_e_scene_manager.html">VESceneManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classve_1_1_v_e_scene_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ve::VESceneManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The scene Manager manages the objects that have been loaded and put into the world.  
 <a href="classve_1_1_v_e_scene_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_v_e_scene_manager_8h_source.html">VESceneManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab734ad6953897388d0bc7ee22369ed3b"><td class="memItemLeft" align="right" valign="top"><a id="ab734ad6953897388d0bc7ee22369ed3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ab734ad6953897388d0bc7ee22369ed3b">VESceneManager</a> ()</td></tr>
<tr class="memdesc:ab734ad6953897388d0bc7ee22369ed3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of class <a class="el" href="classve_1_1_v_e_scene_manager.html" title="The scene Manager manages the objects that have been loaded and put into the world.">VESceneManager</a>. <br /></td></tr>
<tr class="separator:ab734ad6953897388d0bc7ee22369ed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b77d8fc900cdc268ef92dcdfad20ae"><td class="memItemLeft" align="right" valign="top"><a id="a63b77d8fc900cdc268ef92dcdfad20ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a63b77d8fc900cdc268ef92dcdfad20ae">~VESceneManager</a> ()</td></tr>
<tr class="memdesc:a63b77d8fc900cdc268ef92dcdfad20ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of class <a class="el" href="classve_1_1_v_e_scene_manager.html" title="The scene Manager manages the objects that have been loaded and put into the world.">VESceneManager</a>. <br /></td></tr>
<tr class="separator:a63b77d8fc900cdc268ef92dcdfad20ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb42fdaf90df123a6fa6364191d0656b"><td class="memItemLeft" align="right" valign="top">const aiScene *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#afb42fdaf90df123a6fa6364191d0656b">loadAssets</a> (std::string basedir, std::string filename, uint32_t aiFlags, std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;meshes, std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;materials)</td></tr>
<tr class="memdesc:afb42fdaf90df123a6fa6364191d0656b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load assets from file ussing Assimp.  <a href="#afb42fdaf90df123a6fa6364191d0656b">More...</a><br /></td></tr>
<tr class="separator:afb42fdaf90df123a6fa6364191d0656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f329338bd5b87cbdacf86264179b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a92f329338bd5b87cbdacf86264179b96">loadModel</a> (std::string entityName, std::string basedir, std::string filename, uint32_t aiFlags=0, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent=nullptr)</td></tr>
<tr class="memdesc:a92f329338bd5b87cbdacf86264179b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load assets from file ussing Assimp, create entities from them.  <a href="#a92f329338bd5b87cbdacf86264179b96">More...</a><br /></td></tr>
<tr class="separator:a92f329338bd5b87cbdacf86264179b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017d577a3f5629c18e8bc9c215abf3dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a017d577a3f5629c18e8bc9c215abf3dc">createSceneNode</a> (std::string name, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent, glm::mat4 transf=glm::mat4(1.0f))</td></tr>
<tr class="memdesc:a017d577a3f5629c18e8bc9c215abf3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scene node.  <a href="#a017d577a3f5629c18e8bc9c215abf3dc">More...</a><br /></td></tr>
<tr class="separator:a017d577a3f5629c18e8bc9c215abf3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c06807aa21254807363ef92639a7d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a3c06807aa21254807363ef92639a7d52">createEntity</a> (std::string entityName, <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *pMesh, <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *pMat, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent, glm::mat4 transf=glm::mat4(1.0f))</td></tr>
<tr class="memdesc:a3c06807aa21254807363ef92639a7d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an entity.  <a href="#a3c06807aa21254807363ef92639a7d52">More...</a><br /></td></tr>
<tr class="separator:a3c06807aa21254807363ef92639a7d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b2117851761638442e562a93f9476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a1b9b2117851761638442e562a93f9476">createEntity</a> (std::string entityName, <a class="el" href="classve_1_1_v_e_entity.html#a2c7f15fd3b11aac4dea3e76cfa508010">VEEntity::veEntityType</a> type, <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *pMesh, <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *pMat, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent, glm::mat4 transf=glm::mat4(1.0f))</td></tr>
<tr class="memdesc:a1b9b2117851761638442e562a93f9476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an entity.  <a href="#a1b9b2117851761638442e562a93f9476">More...</a><br /></td></tr>
<tr class="separator:a1b9b2117851761638442e562a93f9476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcddfb3df34badfee79b35dd16196f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a0dcddfb3df34badfee79b35dd16196f2">createCamera</a> (std::string cameraName, <a class="el" href="classve_1_1_v_e_camera.html#a2bade7c96b45ffcae80bcc0f111ea0a2">VECamera::veCameraType</a> type, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent, glm::mat4 transf=glm::mat4(1.0f))</td></tr>
<tr class="memdesc:a0dcddfb3df34badfee79b35dd16196f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a camera.  <a href="#a0dcddfb3df34badfee79b35dd16196f2">More...</a><br /></td></tr>
<tr class="separator:a0dcddfb3df34badfee79b35dd16196f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067d300535ffe3210c55c70600e35c4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_light.html">VELight</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a067d300535ffe3210c55c70600e35c4a">createLight</a> (std::string lightName, <a class="el" href="classve_1_1_v_e_light.html#abcedf7166341000b6d4512e9030f6b86">VELight::veLightType</a> type, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent, glm::mat4 transf=glm::mat4(1.0f))</td></tr>
<tr class="memdesc:a067d300535ffe3210c55c70600e35c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a light.  <a href="#a067d300535ffe3210c55c70600e35c4a">More...</a><br /></td></tr>
<tr class="separator:a067d300535ffe3210c55c70600e35c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8af67156442bb6438a1c3a46b8e109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aaa8af67156442bb6438a1c3a46b8e109">createSkyplane</a> (std::string entityName, std::string basedir, std::string texName, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent)</td></tr>
<tr class="memdesc:aaa8af67156442bb6438a1c3a46b8e109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a plane that is projected to the far plane of the frustum.  <a href="#aaa8af67156442bb6438a1c3a46b8e109">More...</a><br /></td></tr>
<tr class="separator:aaa8af67156442bb6438a1c3a46b8e109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb596cddd13574ef55c944c0b4adcff4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#adb596cddd13574ef55c944c0b4adcff4">createSkybox</a> (std::string entityName, std::string basedir, std::vector&lt; std::string &gt; texNames, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent)</td></tr>
<tr class="memdesc:adb596cddd13574ef55c944c0b4adcff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a skyplane based sky box.  <a href="#adb596cddd13574ef55c944c0b4adcff4">More...</a><br /></td></tr>
<tr class="separator:adb596cddd13574ef55c944c0b4adcff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1d754eb2b772fdd7d1fc7bc8d94625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a0f1d754eb2b772fdd7d1fc7bc8d94625">getRootSceneNode</a> ()</td></tr>
<tr class="separator:a0f1d754eb2b772fdd7d1fc7bc8d94625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e85e3bf75295ac40dbca5cbeb452ca"><td class="memItemLeft" align="right" valign="top"><a id="a79e85e3bf75295ac40dbca5cbeb452ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a79e85e3bf75295ac40dbca5cbeb452ca">setAutoRecord</a> (bool flag)</td></tr>
<tr class="memdesc:a79e85e3bf75295ac40dbca5cbeb452ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true then scene graph changes automatically trigger a cmd buffer rerecording. <br /></td></tr>
<tr class="separator:a79e85e3bf75295ac40dbca5cbeb452ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ab8c69e5ea095eb394166db5b246bf"><td class="memItemLeft" align="right" valign="top"><a id="ac0ab8c69e5ea095eb394166db5b246bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ac0ab8c69e5ea095eb394166db5b246bf">sceneGraphChanged</a> ()</td></tr>
<tr class="memdesc:ac0ab8c69e5ea095eb394166db5b246bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called whenever the scene graph ist changed - public API. <br /></td></tr>
<tr class="separator:ac0ab8c69e5ea095eb394166db5b246bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca072d49210df8f3a657e5176270c904"><td class="memItemLeft" align="right" valign="top"><a id="aca072d49210df8f3a657e5176270c904"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aca072d49210df8f3a657e5176270c904">setVisibility</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pNode, bool flag)</td></tr>
<tr class="memdesc:aca072d49210df8f3a657e5176270c904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the visibility of a whole subtree. <br /></td></tr>
<tr class="separator:aca072d49210df8f3a657e5176270c904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd9760111ca205cf97b2fdcfdbb6d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a22dd9760111ca205cf97b2fdcfdbb6d7">getSceneNode</a> (std::string entityName)</td></tr>
<tr class="memdesc:a22dd9760111ca205cf97b2fdcfdbb6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an entity using its name.  <a href="#a22dd9760111ca205cf97b2fdcfdbb6d7">More...</a><br /></td></tr>
<tr class="separator:a22dd9760111ca205cf97b2fdcfdbb6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4964068bea04034d723881b7551dd597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a4964068bea04034d723881b7551dd597">deleteSceneNodeAndChildren</a> (std::string name)</td></tr>
<tr class="memdesc:a4964068bea04034d723881b7551dd597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a scene node and all its subentities.  <a href="#a4964068bea04034d723881b7551dd597">More...</a><br /></td></tr>
<tr class="separator:a4964068bea04034d723881b7551dd597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bced8579dccaf8567fa3dd5263af30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a71bced8579dccaf8567fa3dd5263af30">deleteScene</a> ()</td></tr>
<tr class="memdesc:a71bced8579dccaf8567fa3dd5263af30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of all child entities of a given entity, then delete them.  <a href="#a71bced8579dccaf8567fa3dd5263af30">More...</a><br /></td></tr>
<tr class="separator:a71bced8579dccaf8567fa3dd5263af30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af429201487fd4e085080ed3fc839a8ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#af429201487fd4e085080ed3fc839a8ea">createSceneNodeList</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pObject, std::vector&lt; std::string &gt; &amp;namelist)</td></tr>
<tr class="memdesc:af429201487fd4e085080ed3fc839a8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of all child entities of a given entity.  <a href="#af429201487fd4e085080ed3fc839a8ea">More...</a><br /></td></tr>
<tr class="separator:af429201487fd4e085080ed3fc839a8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8836511f00f0099e3370dadce0fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a7ad8836511f00f0099e3370dadce0fa7">createMesh</a> (std::string name, std::vector&lt; <a class="el" href="structvh_1_1vh_vertex.html">vh::vhVertex</a> &gt; &amp;vertices, std::vector&lt; uint32_t &gt; &amp;indices)</td></tr>
<tr class="memdesc:a7ad8836511f00f0099e3370dadce0fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new mesh with a certain name.  <a href="#a7ad8836511f00f0099e3370dadce0fa7">More...</a><br /></td></tr>
<tr class="separator:a7ad8836511f00f0099e3370dadce0fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1cbd72f3a6408546d62a5c5f1ab14d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a6f1cbd72f3a6408546d62a5c5f1ab14d">getMesh</a> (std::string name)</td></tr>
<tr class="memdesc:a6f1cbd72f3a6408546d62a5c5f1ab14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a mesh by its name and return a pointer to it.  <a href="#a6f1cbd72f3a6408546d62a5c5f1ab14d">More...</a><br /></td></tr>
<tr class="separator:a6f1cbd72f3a6408546d62a5c5f1ab14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ecc663dc2570d4c54b2e36529deb5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a88ecc663dc2570d4c54b2e36529deb5c">deleteMesh</a> (std::string name)</td></tr>
<tr class="memdesc:a88ecc663dc2570d4c54b2e36529deb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a mesh given its name.  <a href="#a88ecc663dc2570d4c54b2e36529deb5c">More...</a><br /></td></tr>
<tr class="separator:a88ecc663dc2570d4c54b2e36529deb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b30cdace056808c79970a3037abcc4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structve_1_1_v_e_texture.html">VETexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a9b30cdace056808c79970a3037abcc4e">createTexture</a> (std::string name, std::string basedir, std::string texName)</td></tr>
<tr class="memdesc:a9b30cdace056808c79970a3037abcc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new texture with a given name.  <a href="#a9b30cdace056808c79970a3037abcc4e">More...</a><br /></td></tr>
<tr class="separator:a9b30cdace056808c79970a3037abcc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15715047c41d28bfe40b7fbff0f19d3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structve_1_1_v_e_texture.html">VETexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a15715047c41d28bfe40b7fbff0f19d3f">getTexture</a> (std::string name)</td></tr>
<tr class="memdesc:a15715047c41d28bfe40b7fbff0f19d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a texture with a given name.  <a href="#a15715047c41d28bfe40b7fbff0f19d3f">More...</a><br /></td></tr>
<tr class="separator:a15715047c41d28bfe40b7fbff0f19d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6b73894110d4389ff194694b0140c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#adb6b73894110d4389ff194694b0140c7">deleteTexture</a> (std::string name)</td></tr>
<tr class="memdesc:adb6b73894110d4389ff194694b0140c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a texture given its name.  <a href="#adb6b73894110d4389ff194694b0140c7">More...</a><br /></td></tr>
<tr class="separator:adb6b73894110d4389ff194694b0140c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9a23d8d6ae3b4494b4f9ead78ffc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#acd9a23d8d6ae3b4494b4f9ead78ffc64">createMaterial</a> (std::string name)</td></tr>
<tr class="memdesc:acd9a23d8d6ae3b4494b4f9ead78ffc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new material with a given name.  <a href="#acd9a23d8d6ae3b4494b4f9ead78ffc64">More...</a><br /></td></tr>
<tr class="separator:acd9a23d8d6ae3b4494b4f9ead78ffc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38797639b891b1b0d30ce929e9f7aa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ac38797639b891b1b0d30ce929e9f7aa0">getMaterial</a> (std::string name)</td></tr>
<tr class="memdesc:ac38797639b891b1b0d30ce929e9f7aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a material by its name and return a pointer to it.  <a href="#ac38797639b891b1b0d30ce929e9f7aa0">More...</a><br /></td></tr>
<tr class="separator:ac38797639b891b1b0d30ce929e9f7aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ca7fe353361e0da3ee4a850f57d3ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a16ca7fe353361e0da3ee4a850f57d3ce">deleteMaterial</a> (std::string name)</td></tr>
<tr class="memdesc:a16ca7fe353361e0da3ee4a850f57d3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a material given its name.  <a href="#a16ca7fe353361e0da3ee4a850f57d3ce">More...</a><br /></td></tr>
<tr class="separator:a16ca7fe353361e0da3ee4a850f57d3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dedc85430da2d06259704f47ec4f3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a6dedc85430da2d06259704f47ec4f3c7">getCamera</a> ()</td></tr>
<tr class="separator:a6dedc85430da2d06259704f47ec4f3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedf235e65ee027a0df5dc92163fcefe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#acedf235e65ee027a0df5dc92163fcefe">setCamera</a> (<a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *cam)</td></tr>
<tr class="memdesc:acedf235e65ee027a0df5dc92163fcefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the the current camera.  <a href="#acedf235e65ee027a0df5dc92163fcefe">More...</a><br /></td></tr>
<tr class="separator:acedf235e65ee027a0df5dc92163fcefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e8d10dcab7cce48b9b5c28acda0ead"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classve_1_1_v_e_light.html">VELight</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ad5e8d10dcab7cce48b9b5c28acda0ead">getLights</a> ()</td></tr>
<tr class="separator:ad5e8d10dcab7cce48b9b5c28acda0ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f64a8b8e2fbb1528cba99c6714fb20"><td class="memItemLeft" align="right" valign="top"><a id="ab8f64a8b8e2fbb1528cba99c6714fb20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ab8f64a8b8e2fbb1528cba99c6714fb20">printSceneNodes</a> ()</td></tr>
<tr class="memdesc:ab8f64a8b8e2fbb1528cba99c6714fb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of all entities to the console. <br /></td></tr>
<tr class="separator:ab8f64a8b8e2fbb1528cba99c6714fb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e458ea6b4d9ab6ceadfb0213f5f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#af59e458ea6b4d9ab6ceadfb0213f5f49">printTree</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *root)</td></tr>
<tr class="memdesc:af59e458ea6b4d9ab6ceadfb0213f5f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of all entities in an entity tree to the console.  <a href="#af59e458ea6b4d9ab6ceadfb0213f5f49">More...</a><br /></td></tr>
<tr class="separator:af59e458ea6b4d9ab6ceadfb0213f5f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a612ac89ae22a8cdec8b975173b5eeb5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a612ac89ae22a8cdec8b975173b5eeb5c">initSceneManager</a> ()</td></tr>
<tr class="memdesc:a612ac89ae22a8cdec8b975173b5eeb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the scene manager.  <a href="#a612ac89ae22a8cdec8b975173b5eeb5c">More...</a><br /></td></tr>
<tr class="separator:a612ac89ae22a8cdec8b975173b5eeb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8871bfddf3e3f7497fcdf1b680dc0e48"><td class="memItemLeft" align="right" valign="top"><a id="a8871bfddf3e3f7497fcdf1b680dc0e48"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a8871bfddf3e3f7497fcdf1b680dc0e48">closeSceneManager</a> ()</td></tr>
<tr class="memdesc:a8871bfddf3e3f7497fcdf1b680dc0e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close down the scene manager and delete all its assets. <br /></td></tr>
<tr class="separator:a8871bfddf3e3f7497fcdf1b680dc0e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dffe81f507aafc98ce88bde78f7c61a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a0dffe81f507aafc98ce88bde78f7c61a">createMeshes</a> (const aiScene *pScene, std::string filekey, std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;meshes)</td></tr>
<tr class="memdesc:a0dffe81f507aafc98ce88bde78f7c61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create all <a class="el" href="classve_1_1_v_e_mesh.html" title="Store a mesh in a Vulkan vertex and index buffer.">VEMesh</a> instances from a file loaded by Assimp.  <a href="#a0dffe81f507aafc98ce88bde78f7c61a">More...</a><br /></td></tr>
<tr class="separator:a0dffe81f507aafc98ce88bde78f7c61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cb40d0509a6db4730d8204d08a8c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a40cb40d0509a6db4730d8204d08a8c12">createMaterials</a> (const aiScene *pScene, std::string basedir, std::string filekey, std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;materials)</td></tr>
<tr class="memdesc:a40cb40d0509a6db4730d8204d08a8c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create all <a class="el" href="classve_1_1_v_e_material.html" title="Store material data.">VEMaterial</a> instances from a file loaded by Assimp.  <a href="#a40cb40d0509a6db4730d8204d08a8c12">More...</a><br /></td></tr>
<tr class="separator:a40cb40d0509a6db4730d8204d08a8c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b7bccb70db3400ec513839c97e958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a219b7bccb70db3400ec513839c97e958">copyAiNodes</a> (const aiScene *pScene, std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;meshes, std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;materials, aiNode *node, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent)</td></tr>
<tr class="memdesc:a219b7bccb70db3400ec513839c97e958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follow the Assimp tree of nodes and create entities from them.  <a href="#a219b7bccb70db3400ec513839c97e958">More...</a><br /></td></tr>
<tr class="separator:a219b7bccb70db3400ec513839c97e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e057538e09e704fb36f1902f66d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a1b5e057538e09e704fb36f1902f66d69">createSceneNode2</a> (std::string name, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent, glm::mat4 transf=glm::mat4(1.0f))</td></tr>
<tr class="memdesc:a1b5e057538e09e704fb36f1902f66d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scene node.  <a href="#a1b5e057538e09e704fb36f1902f66d69">More...</a><br /></td></tr>
<tr class="separator:a1b5e057538e09e704fb36f1902f66d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf964ec97e38cb8eea8154cc7cbbe24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#acdf964ec97e38cb8eea8154cc7cbbe24">createEntity2</a> (std::string entityName, <a class="el" href="classve_1_1_v_e_entity.html#a2c7f15fd3b11aac4dea3e76cfa508010">VEEntity::veEntityType</a> type, <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *pMesh, <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *pMat, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent, glm::mat4 transf=glm::mat4(1.0f))</td></tr>
<tr class="memdesc:acdf964ec97e38cb8eea8154cc7cbbe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an entity.  <a href="#acdf964ec97e38cb8eea8154cc7cbbe24">More...</a><br /></td></tr>
<tr class="separator:acdf964ec97e38cb8eea8154cc7cbbe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d04ba7bd4af9ef0b351abc14a67aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a13d04ba7bd4af9ef0b351abc14a67aca">addSceneNodeAndChildren2</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pNode, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent)</td></tr>
<tr class="memdesc:a13d04ba7bd4af9ef0b351abc14a67aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new scene node into the scene.  <a href="#a13d04ba7bd4af9ef0b351abc14a67aca">More...</a><br /></td></tr>
<tr class="separator:a13d04ba7bd4af9ef0b351abc14a67aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3d36e87484587a20368624375f83f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aeb3d36e87484587a20368624375f83f2">deleteSceneNodeAndChildren2</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pNode)</td></tr>
<tr class="memdesc:aeb3d36e87484587a20368624375f83f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a scene node and all its subentities.  <a href="#aeb3d36e87484587a20368624375f83f2">More...</a><br /></td></tr>
<tr class="separator:aeb3d36e87484587a20368624375f83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc826a52baf88f30f2239a875052eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#adfc826a52baf88f30f2239a875052eea">createSceneNodeList2</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pObject, std::vector&lt; std::string &gt; &amp;namelist)</td></tr>
<tr class="memdesc:adfc826a52baf88f30f2239a875052eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of all child entities of a given entity.  <a href="#adfc826a52baf88f30f2239a875052eea">More...</a><br /></td></tr>
<tr class="separator:adfc826a52baf88f30f2239a875052eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad250648db656e3ab87a8157df1e044a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ad250648db656e3ab87a8157df1e044a8">createSkyplane2</a> (std::string entityName, std::string basedir, std::string texName, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *parent)</td></tr>
<tr class="memdesc:ad250648db656e3ab87a8157df1e044a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a plane that is projected to the far plane of the frustum.  <a href="#ad250648db656e3ab87a8157df1e044a8">More...</a><br /></td></tr>
<tr class="separator:ad250648db656e3ab87a8157df1e044a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1823a1e5cd400b35b46ce2149e4177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structve_1_1_v_e_texture.html">VETexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aec1823a1e5cd400b35b46ce2149e4177">createTexture2</a> (std::string name, std::string basedir, std::string texName)</td></tr>
<tr class="memdesc:aec1823a1e5cd400b35b46ce2149e4177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new texture with a given name.  <a href="#aec1823a1e5cd400b35b46ce2149e4177">More...</a><br /></td></tr>
<tr class="separator:aec1823a1e5cd400b35b46ce2149e4177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8dbb32ba5f8a7be013cf410030ba4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a1b8dbb32ba5f8a7be013cf410030ba4d">createMaterial2</a> (std::string name)</td></tr>
<tr class="memdesc:a1b8dbb32ba5f8a7be013cf410030ba4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new material with a given name.  <a href="#a1b8dbb32ba5f8a7be013cf410030ba4d">More...</a><br /></td></tr>
<tr class="separator:a1b8dbb32ba5f8a7be013cf410030ba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6929a5a216090f467a4daa5722173d5"><td class="memItemLeft" align="right" valign="top"><a id="aa6929a5a216090f467a4daa5722173d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aa6929a5a216090f467a4daa5722173d5">sceneGraphChanged2</a> ()</td></tr>
<tr class="memdesc:aa6929a5a216090f467a4daa5722173d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called whenever the scene graph ist changed - internal version called automatically after changes. <br /></td></tr>
<tr class="separator:aa6929a5a216090f467a4daa5722173d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a31c03423ccba2d50f312250a0e5d"><td class="memItemLeft" align="right" valign="top"><a id="ab15a31c03423ccba2d50f312250a0e5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ab15a31c03423ccba2d50f312250a0e5d">sceneGraphChanged3</a> ()</td></tr>
<tr class="memdesc:ab15a31c03423ccba2d50f312250a0e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called whenever the scene graph ist changed. <br /></td></tr>
<tr class="separator:ab15a31c03423ccba2d50f312250a0e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadccc0f574cd30019e940ab56acc832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aaadccc0f574cd30019e940ab56acc832">updateSceneNodes</a> (uint32_t imageIndex)</td></tr>
<tr class="memdesc:aaadccc0f574cd30019e940ab56acc832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all scene nodes without a parent, then update them and their children.  <a href="#aaadccc0f574cd30019e940ab56acc832">More...</a><br /></td></tr>
<tr class="separator:aaadccc0f574cd30019e940ab56acc832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcd94dbc425dd23d1c6b696c5c0fd16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aabcd94dbc425dd23d1c6b696c5c0fd16">updateSceneNodes2</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pNode, glm::mat4 worldMatrix, uint32_t imageIndex)</td></tr>
<tr class="memdesc:aabcd94dbc425dd23d1c6b696c5c0fd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update this node and all its children.  <a href="#aabcd94dbc425dd23d1c6b696c5c0fd16">More...</a><br /></td></tr>
<tr class="separator:aabcd94dbc425dd23d1c6b696c5c0fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e02f9a8f6b823aa020e686f682b196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a26e02f9a8f6b823aa020e686f682b196">updateSceneNodes3</a> (std::vector&lt; <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * &gt; &amp;children, glm::mat4 worldMatrix, uint32_t startIdx, uint32_t endIdx, uint32_t imageIndex)</td></tr>
<tr class="memdesc:a26e02f9a8f6b823aa020e686f682b196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a list of nodes and all their children.  <a href="#a26e02f9a8f6b823aa020e686f682b196">More...</a><br /></td></tr>
<tr class="separator:a26e02f9a8f6b823aa020e686f682b196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0e2b8122dc9e89dc62e24fec38b3e6"><td class="memItemLeft" align="right" valign="top"><a id="a7a0e2b8122dc9e89dc62e24fec38b3e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a7a0e2b8122dc9e89dc62e24fec38b3e6">setVisibility2</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pNode, bool flag)</td></tr>
<tr class="memdesc:a7a0e2b8122dc9e89dc62e24fec38b3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the visibility of a whole subtree. <br /></td></tr>
<tr class="separator:a7a0e2b8122dc9e89dc62e24fec38b3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb7c8d6b2a29bd322b575994c9b9933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a2eb7c8d6b2a29bd322b575994c9b9933">notifyEventListeners</a> (<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *pNode)</td></tr>
<tr class="memdesc:a2eb7c8d6b2a29bd322b575994c9b9933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify event listeners that a scene node has been deleted.  <a href="#a2eb7c8d6b2a29bd322b575994c9b9933">More...</a><br /></td></tr>
<tr class="separator:a2eb7c8d6b2a29bd322b575994c9b9933"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a83355400bed0580ec493733a720a4e9a"><td class="memItemLeft" align="right" valign="top"><a id="a83355400bed0580ec493733a720a4e9a"></a>
std::map&lt; std::string, <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a83355400bed0580ec493733a720a4e9a">m_meshes</a> = {}</td></tr>
<tr class="memdesc:a83355400bed0580ec493733a720a4e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of all meshes currently in the engine. <br /></td></tr>
<tr class="separator:a83355400bed0580ec493733a720a4e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39af0adfbb5a525c8084e4f42240181d"><td class="memItemLeft" align="right" valign="top"><a id="a39af0adfbb5a525c8084e4f42240181d"></a>
std::map&lt; std::string, <a class="el" href="structve_1_1_v_e_texture.html">VETexture</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a39af0adfbb5a525c8084e4f42240181d">m_textures</a> = {}</td></tr>
<tr class="memdesc:a39af0adfbb5a525c8084e4f42240181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of all textures. <br /></td></tr>
<tr class="separator:a39af0adfbb5a525c8084e4f42240181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9181d84127dae4c7d304fc40577e86c"><td class="memItemLeft" align="right" valign="top"><a id="aa9181d84127dae4c7d304fc40577e86c"></a>
std::map&lt; std::string, <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aa9181d84127dae4c7d304fc40577e86c">m_materials</a> = {}</td></tr>
<tr class="memdesc:aa9181d84127dae4c7d304fc40577e86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of all materials currently in the engine. <br /></td></tr>
<tr class="separator:aa9181d84127dae4c7d304fc40577e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeedb9ee5317fcf9dcdca724dcb86b2b"><td class="memItemLeft" align="right" valign="top"><a id="aaeedb9ee5317fcf9dcdca724dcb86b2b"></a>
std::map&lt; std::string, <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aaeedb9ee5317fcf9dcdca724dcb86b2b">m_sceneNodes</a> = {}</td></tr>
<tr class="memdesc:aaeedb9ee5317fcf9dcdca724dcb86b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of all scene nodes currently in the engine. <br /></td></tr>
<tr class="separator:aaeedb9ee5317fcf9dcdca724dcb86b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaf6d1d7514e861ca79cac07287798f"><td class="memItemLeft" align="right" valign="top"><a id="a6aaf6d1d7514e861ca79cac07287798f"></a>
std::vector&lt; <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a6aaf6d1d7514e861ca79cac07287798f">m_deletedSceneNodes</a> = {}</td></tr>
<tr class="memdesc:a6aaf6d1d7514e861ca79cac07287798f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of deleted scene nodes and their children. <br /></td></tr>
<tr class="separator:a6aaf6d1d7514e861ca79cac07287798f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fee4d83dc3766d0e44fea509fc46e42"><td class="memItemLeft" align="right" valign="top"><a id="a2fee4d83dc3766d0e44fea509fc46e42"></a>
<a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a2fee4d83dc3766d0e44fea509fc46e42">m_rootSceneNode</a></td></tr>
<tr class="memdesc:a2fee4d83dc3766d0e44fea509fc46e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root node of the scene graph. <br /></td></tr>
<tr class="separator:a2fee4d83dc3766d0e44fea509fc46e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9c3dc020e29b827005e3a676e7112d"><td class="memItemLeft" align="right" valign="top"><a id="a7c9c3dc020e29b827005e3a676e7112d"></a>
std::map&lt; <a class="el" href="classve_1_1_v_e_scene_object.html#a01743df3f6eb6b2edfc3940860e90d99">VESceneObject::veObjectType</a>, std::vector&lt; <a class="el" href="structvh_1_1vh_memory_block.html">vh::vhMemoryBlock</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a7c9c3dc020e29b827005e3a676e7112d">m_memoryBlockMap</a></td></tr>
<tr class="memdesc:a7c9c3dc020e29b827005e3a676e7112d"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory for the UBOs of the entities <br /></td></tr>
<tr class="separator:a7c9c3dc020e29b827005e3a676e7112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2d6291204fad10a21c930485baadf0"><td class="memItemLeft" align="right" valign="top"><a id="aaf2d6291204fad10a21c930485baadf0"></a>
std::queue&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#aaf2d6291204fad10a21c930485baadf0">m_updateFutures</a></td></tr>
<tr class="memdesc:aaf2d6291204fad10a21c930485baadf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">we might do UBO updates in parallel, these are the futures to wait for <br /></td></tr>
<tr class="separator:aaf2d6291204fad10a21c930485baadf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fbd394a2d6ff4797ecff2921d6cbcb"><td class="memItemLeft" align="right" valign="top"><a id="ae3fbd394a2d6ff4797ecff2921d6cbcb"></a>
<a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#ae3fbd394a2d6ff4797ecff2921d6cbcb">m_camera</a> = nullptr</td></tr>
<tr class="memdesc:ae3fbd394a2d6ff4797ecff2921d6cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ptr to the current camera. <br /></td></tr>
<tr class="separator:ae3fbd394a2d6ff4797ecff2921d6cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9304990871bbe6cc0abd0351929439"><td class="memItemLeft" align="right" valign="top"><a id="a0c9304990871bbe6cc0abd0351929439"></a>
std::vector&lt; <a class="el" href="classve_1_1_v_e_light.html">VELight</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a0c9304990871bbe6cc0abd0351929439">m_lights</a> = {}</td></tr>
<tr class="memdesc:a0c9304990871bbe6cc0abd0351929439"><td class="mdescLeft">&#160;</td><td class="mdescRight">ptrs to the lights to use - filled automatically <br /></td></tr>
<tr class="separator:a0c9304990871bbe6cc0abd0351929439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8599d3a15f3fd43b31cd17cc4cfedc81"><td class="memItemLeft" align="right" valign="top"><a id="a8599d3a15f3fd43b31cd17cc4cfedc81"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a8599d3a15f3fd43b31cd17cc4cfedc81">m_mutex</a></td></tr>
<tr class="memdesc:a8599d3a15f3fd43b31cd17cc4cfedc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex for multithreading, locks the scene manager. <br /></td></tr>
<tr class="separator:a8599d3a15f3fd43b31cd17cc4cfedc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a26a0554de7906e1e046e7638c4977d"><td class="memItemLeft" align="right" valign="top"><a id="a7a26a0554de7906e1e046e7638c4977d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classve_1_1_v_e_scene_manager.html#a7a26a0554de7906e1e046e7638c4977d">m_autoRecord</a> = true</td></tr>
<tr class="memdesc:a7a26a0554de7906e1e046e7638c4977d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if true, then scene graph changes automatically leasd to a cmd buffer rerecording <br /></td></tr>
<tr class="separator:a7a26a0554de7906e1e046e7638c4977d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The scene Manager manages the objects that have been loaded and put into the world. </p>
<p>The scene manager can load objects from file and place them into the world. It also maintains cameras and lights. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a13d04ba7bd4af9ef0b351abc14a67aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d04ba7bd4af9ef0b351abc14a67aca">&#9670;&nbsp;</a></span>addSceneNodeAndChildren2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::addSceneNodeAndChildren2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new scene node into the scene. </p>
<p>If the parent is the nullptr then make the root scene node its parent. This is the protected shadow function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNode</td><td>Pointer to the new scene node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to the new parent of this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a219b7bccb70db3400ec513839c97e958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219b7bccb70db3400ec513839c97e958">&#9670;&nbsp;</a></span>copyAiNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::copyAiNodes </td>
          <td>(</td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>materials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">aiNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Follow the Assimp tree of nodes and create entities from them. </p>
<p>Assimp returns a tree of nodes, each node having one or more meshes. Since an <a class="el" href="classve_1_1_v_e_entity.html" title="Represents any object that can be drawn.">VEEntity</a> can have only one mesh, for each of the meshes one <a class="el" href="classve_1_1_v_e_entity.html" title="Represents any object that can be drawn.">VEEntity</a> is created and being made the child of the current parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pScene</td><td>A pointer to the Assimp scene </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>The meshes that were loaded by Assimp from the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">materials</td><td>The materials that were loaded by Assimp from the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The Assimp node currently being processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent entity of the new entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dcddfb3df34badfee79b35dd16196f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcddfb3df34badfee79b35dd16196f2">&#9670;&nbsp;</a></span>createCamera()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> * ve::VESceneManager::createCamera </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cameraName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_camera.html#a2bade7c96b45ffcae80bcc0f111ea0a2">VECamera::veCameraType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraName</td><td>The name of the new camera. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The camera type to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform, given as GLM matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new camera </dd></dl>

</div>
</div>
<a id="a3c06807aa21254807363ef92639a7d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c06807aa21254807363ef92639a7d52">&#9670;&nbsp;</a></span>createEntity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createEntity </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td>
          <td class="paramname"><em>pMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>The name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td>Pointer the mesh for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMat</td><td>Pointer to the material for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform, given as GLM matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a1b9b2117851761638442e562a93f9476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9b2117851761638442e562a93f9476">&#9670;&nbsp;</a></span>createEntity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createEntity </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_entity.html#a2c7f15fd3b11aac4dea3e76cfa508010">VEEntity::veEntityType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td>
          <td class="paramname"><em>pMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>The name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The entity type to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td>Pointer the mesh for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMat</td><td>Pointer to the material for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform, given as GLM matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="acdf964ec97e38cb8eea8154cc7cbbe24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf964ec97e38cb8eea8154cc7cbbe24">&#9670;&nbsp;</a></span>createEntity2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createEntity2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_entity.html#a2c7f15fd3b11aac4dea3e76cfa508010">VEEntity::veEntityType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> *&#160;</td>
          <td class="paramname"><em>pMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>The name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The entity type to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td>Pointer the mesh for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMat</td><td>Pointer to the material for this entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform, given as GLM matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a067d300535ffe3210c55c70600e35c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067d300535ffe3210c55c70600e35c4a">&#9670;&nbsp;</a></span>createLight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_light.html">VELight</a> * ve::VESceneManager::createLight </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>lightName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_light.html#abcedf7166341000b6d4512e9030f6b86">VELight::veLightType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a light. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightName</td><td>The name of the new camera. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The light type to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to scene node to be used as parent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform, given as GLM matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new light </dd></dl>

</div>
</div>
<a id="acd9a23d8d6ae3b4494b4f9ead78ffc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9a23d8d6ae3b4494b4f9ead78ffc64">&#9670;&nbsp;</a></span>createMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * ve::VESceneManager::createMaterial </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new material with a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the material. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new material, or an old one if one with this name was found </dd></dl>

</div>
</div>
<a id="a1b8dbb32ba5f8a7be013cf410030ba4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8dbb32ba5f8a7be013cf410030ba4d">&#9670;&nbsp;</a></span>createMaterial2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * ve::VESceneManager::createMaterial2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new material with a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the material. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new material, or an old one if one with this name was found </dd></dl>

</div>
</div>
<a id="a40cb40d0509a6db4730d8204d08a8c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cb40d0509a6db4730d8204d08a8c12">&#9670;&nbsp;</a></span>createMaterials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::createMaterials </td>
          <td>(</td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filekey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create all <a class="el" href="classve_1_1_v_e_material.html" title="Store material data.">VEMaterial</a> instances from a file loaded by Assimp. </p>
<p>Once Assimp loaded a file it offers a global list of materials. The function just goes through this list and creates <a class="el" href="classve_1_1_v_e_material.html" title="Store material data.">VEMaterial</a> instances, then stores pointers to the in the materials list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pScene</td><td>Pointer to the Assimp scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the file is in (for loading textures) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filekey</td><td>Unique string identifying this file. Can be used for the mesh names. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">materials</td><td>List of new materials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ad8836511f00f0099e3370dadce0fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad8836511f00f0099e3370dadce0fa7">&#9670;&nbsp;</a></span>createMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * ve::VESceneManager::createMesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvh_1_1vh_vertex.html">vh::vhVertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new mesh with a certain name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>Vertices of the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Indices of the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new mesh or an old one if it exists with this name </dd></dl>

</div>
</div>
<a id="a0dffe81f507aafc98ce88bde78f7c61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dffe81f507aafc98ce88bde78f7c61a">&#9670;&nbsp;</a></span>createMeshes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::createMeshes </td>
          <td>(</td>
          <td class="paramtype">const aiScene *&#160;</td>
          <td class="paramname"><em>pScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filekey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create all <a class="el" href="classve_1_1_v_e_mesh.html" title="Store a mesh in a Vulkan vertex and index buffer.">VEMesh</a> instances from a file loaded by Assimp. </p>
<p>Once Assimp loaded a file it offers a global list of meshes. The function just goes through this list and creates <a class="el" href="classve_1_1_v_e_mesh.html" title="Store a mesh in a Vulkan vertex and index buffer.">VEMesh</a> instances, then stores pointers to the in the meshes list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pScene</td><td>Pointer to the Assimp scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filekey</td><td>Unique string identifying this file. Can be used for the mesh names. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshes</td><td>List of new meshes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a017d577a3f5629c18e8bc9c215abf3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017d577a3f5629c18e8bc9c215abf3dc">&#9670;&nbsp;</a></span>createSceneNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::createSceneNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scene node. </p>
<p>Calls its own shadow function, so that it does not block itself when called by another public function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objectName</td><td>The name of the new MO. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new scene node </dd></dl>

</div>
</div>
<a id="a1b5e057538e09e704fb36f1902f66d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5e057538e09e704fb36f1902f66d69">&#9670;&nbsp;</a></span>createSceneNode2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::createSceneNode2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>transf</em> = <code>glm::mat4(1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a scene node. </p>
<p>This is a protected shadow funtion of the public API function. It can be called by other public functions that lock the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objectName</td><td>The name of the new MO. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transf</td><td>Local to parent transform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to entity to be used as parent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new scene node </dd></dl>

</div>
</div>
<a id="af429201487fd4e085080ed3fc839a8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af429201487fd4e085080ed3fc839a8ea">&#9670;&nbsp;</a></span>createSceneNodeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::createSceneNodeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namelist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list of all child entities of a given entity. </p>
<p>Public API function locks the mutex, then calls its shadow function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pObject</td><td>Pointer to the root of the tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">namelist</td><td>List of names of children of the entity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfc826a52baf88f30f2239a875052eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc826a52baf88f30f2239a875052eea">&#9670;&nbsp;</a></span>createSceneNodeList2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::createSceneNodeList2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namelist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a list of all child entities of a given entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pObject</td><td>Pointer to the root of the tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">namelist</td><td>List of names of children of the entity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb596cddd13574ef55c944c0b4adcff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb596cddd13574ef55c944c0b4adcff4">&#9670;&nbsp;</a></span>createSkybox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::createSkybox </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>texNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a skyplane based sky box. </p>
<p>This function loads 5 textures to use them as sky planes. The bottom plane is not loaded The order of the tex names must be ft bk up dn rt lf</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>Name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the texture file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texNames</td><td>List of 6 names of the texture files. Order must be ft bk up dn rt lf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to a scene node that is the parent of this box, should be root node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity, which is the parent of the planes </dd></dl>

</div>
</div>
<a id="aaa8af67156442bb6438a1c3a46b8e109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8af67156442bb6438a1c3a46b8e109">&#9670;&nbsp;</a></span>createSkyplane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createSkyplane </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>texName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a plane that is projected to the far plane of the frustum. </p>
<p>Public API that locks the mutex and then calls its won shadow function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>Name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the texture file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texName</td><td>name of a texture file that contains the sky texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to the parent of this skyplane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="ad250648db656e3ab87a8157df1e044a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad250648db656e3ab87a8157df1e044a8">&#9670;&nbsp;</a></span>createSkyplane2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_entity.html">VEEntity</a> * ve::VESceneManager::createSkyplane2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>texName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a plane that is projected to the far plane of the frustum. </p>
<p>Protected shadow function that creates the plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>Name of the new entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the texture file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texName</td><td>name of a texture file that contains the sky texture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Pointer to the parent of this skyplane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entity </dd></dl>

</div>
</div>
<a id="a9b30cdace056808c79970a3037abcc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b30cdace056808c79970a3037abcc4e">&#9670;&nbsp;</a></span>createTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structve_1_1_v_e_texture.html">VETexture</a> * ve::VESceneManager::createTexture </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>texName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new texture with a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texName</td><td>Filename of the texture file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new texture, or an old one if one with this name was found </dd></dl>

</div>
</div>
<a id="aec1823a1e5cd400b35b46ce2149e4177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1823a1e5cd400b35b46ce2149e4177">&#9670;&nbsp;</a></span>createTexture2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structve_1_1_v_e_texture.html">VETexture</a> * ve::VESceneManager::createTexture2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>texName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new texture with a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of the directory the file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texName</td><td>Filename of the texture file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new texture, or an old one if one with this name was found </dd></dl>

</div>
</div>
<a id="a16ca7fe353361e0da3ee4a850f57d3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca7fe353361e0da3ee4a850f57d3ce">&#9670;&nbsp;</a></span>deleteMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteMaterial </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a material given its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the material. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ecc663dc2570d4c54b2e36529deb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ecc663dc2570d4c54b2e36529deb5c">&#9670;&nbsp;</a></span>deleteMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteMesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a mesh given its name. </p>
<p>This function does NOT check whether the mesh is still used by some entity! It should be only called if this is certain, e.g. if the whole scene is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71bced8579dccaf8567fa3dd5263af30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bced8579dccaf8567fa3dd5263af30">&#9670;&nbsp;</a></span>deleteScene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list of all child entities of a given entity, then delete them. </p>
<p>Function will delete all children of the root scene node, bit not the root itself </p>

</div>
</div>
<a id="a4964068bea04034d723881b7551dd597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4964068bea04034d723881b7551dd597">&#9670;&nbsp;</a></span>deleteSceneNodeAndChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteSceneNodeAndChildren </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a scene node and all its subentities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb3d36e87484587a20368624375f83f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3d36e87484587a20368624375f83f2">&#9670;&nbsp;</a></span>deleteSceneNodeAndChildren2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteSceneNodeAndChildren2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a scene node and all its subentities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNode</td><td>Pointer to the scene node to be deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6b73894110d4389ff194694b0140c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6b73894110d4389ff194694b0140c7">&#9670;&nbsp;</a></span>deleteTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::deleteTexture </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a texture given its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the texture to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dedc85430da2d06259704f47ec4f3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dedc85430da2d06259704f47ec4f3c7">&#9670;&nbsp;</a></span>getCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a>* ve::VESceneManager::getCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the current camera </dd></dl>

</div>
</div>
<a id="ad5e8d10dcab7cce48b9b5c28acda0ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e8d10dcab7cce48b9b5c28acda0ead">&#9670;&nbsp;</a></span>getLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classve_1_1_v_e_light.html">VELight</a>*&gt;&amp; ve::VESceneManager::getLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a list with names of the current lights shining on the scene </dd></dl>

</div>
</div>
<a id="ac38797639b891b1b0d30ce929e9f7aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38797639b891b1b0d30ce929e9f7aa0">&#9670;&nbsp;</a></span>getMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * ve::VESceneManager::getMaterial </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a material by its name and return a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a material given its name </dd></dl>

</div>
</div>
<a id="a6f1cbd72f3a6408546d62a5c5f1ab14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1cbd72f3a6408546d62a5c5f1ab14d">&#9670;&nbsp;</a></span>getMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * ve::VESceneManager::getMesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a mesh by its name and return a pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mesh given its name </dd></dl>

</div>
</div>
<a id="a0f1d754eb2b772fdd7d1fc7bc8d94625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1d754eb2b772fdd7d1fc7bc8d94625">&#9670;&nbsp;</a></span>getRootSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a>* ve::VESceneManager::getRootSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the root scene node </dd></dl>

</div>
</div>
<a id="a22dd9760111ca205cf97b2fdcfdbb6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dd9760111ca205cf97b2fdcfdbb6d7">&#9670;&nbsp;</a></span>getSceneNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::getSceneNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an entity using its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the entity </dd></dl>

</div>
</div>
<a id="a15715047c41d28bfe40b7fbff0f19d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15715047c41d28bfe40b7fbff0f19d3f">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structve_1_1_v_e_texture.html">VETexture</a> * ve::VESceneManager::getTexture </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a texture with a given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the texture </dd></dl>

</div>
</div>
<a id="a612ac89ae22a8cdec8b975173b5eeb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612ac89ae22a8cdec8b975173b5eeb5c">&#9670;&nbsp;</a></span>initSceneManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::initSceneManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the scene manager. </p>
<p>In this function the scene manager loads standard shapes like cubes and planes. Then it creates a standard camera system (camera + parent) and a standard light. </p>

</div>
</div>
<a id="afb42fdaf90df123a6fa6364191d0656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb42fdaf90df123a6fa6364191d0656b">&#9670;&nbsp;</a></span>loadAssets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const aiScene * ve::VESceneManager::loadAssets </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aiFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_mesh.html">VEMesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_material.html">VEMaterial</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load assets from file ussing Assimp. </p>
<p>The scene manager loads assets from a file and creates the contained meshes and materials. It does not create entities. Meshes and materials are stored in the scene manager's member variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of directory the file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file containing the assets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiFlags</td><td>Import flags for Assimp, see code below for some examples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">meshes</td><td>A list containing pointers to the loaded meshes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">materials</td><td>A list of pointers to the loaded materials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92f329338bd5b87cbdacf86264179b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f329338bd5b87cbdacf86264179b96">&#9670;&nbsp;</a></span>loadModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * ve::VESceneManager::loadModel </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>basedir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aiFlags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load assets from file ussing Assimp, create entities from them. </p>
<p>The scene manager loads assets from a file and creates the contained meshes and materials. Meshes and materials are stored in the scene manager's member variables. It then followsa the entity tree recursively and creates the contained entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entityName</td><td>The name of the new entity (its the parent of all created entities) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basedir</td><td>Name of directory the file is in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the file containing the assets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiFlags</td><td>Import flags for Assimp, see code below for some examples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Make the new entity a child of this parent entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2eb7c8d6b2a29bd322b575994c9b9933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb7c8d6b2a29bd322b575994c9b9933">&#9670;&nbsp;</a></span>notifyEventListeners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::notifyEventListeners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify event listeners that a scene node has been deleted. </p>
<p>Event listeners aswering true will also be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNode</td><td>Pointer to scene node that has been deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af59e458ea6b4d9ab6ceadfb0213f5f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59e458ea6b4d9ab6ceadfb0213f5f49">&#9670;&nbsp;</a></span>printTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::printTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a list of all entities in an entity tree to the console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>Pointer to the root entity of the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acedf235e65ee027a0df5dc92163fcefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedf235e65ee027a0df5dc92163fcefe">&#9670;&nbsp;</a></span>setCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::setCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_camera.html">VECamera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the the current camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cam</td><td>Pointer to the camera </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaadccc0f574cd30019e940ab56acc832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadccc0f574cd30019e940ab56acc832">&#9670;&nbsp;</a></span>updateSceneNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::updateSceneNodes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all scene nodes without a parent, then update them and their children. </p>
<p>Makes this nodes and their children to copy their data to the GPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imageIndex</td><td>Index of the swapchain image that is currently used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabcd94dbc425dd23d1c6b696c5c0fd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcd94dbc425dd23d1c6b696c5c0fd16">&#9670;&nbsp;</a></span>updateSceneNodes2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::updateSceneNodes2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>parentWorldMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update this node and all its children. </p>
<p>Makes this nodes and their children to copy their data to the GPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNode</td><td>Pointer to the node to start updating </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parentWorldMatrix</td><td>World Matrix of the parent, used as a start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageIndex</td><td>Index of the swapchain image that is currently used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26e02f9a8f6b823aa020e686f682b196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e02f9a8f6b823aa020e686f682b196">&#9670;&nbsp;</a></span>updateSceneNodes3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ve::VESceneManager::updateSceneNodes3 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classve_1_1_v_e_scene_node.html">VESceneNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4&#160;</td>
          <td class="paramname"><em>worldMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>imageIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a list of nodes and all their children. </p>
<p>This function can be called in parallel on subparts of a children list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">children</td><td>Reference to a list of children </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldMatrix</td><td>Parent world matrix for the children </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIdx</td><td>Start index pointing to the child to start at in the children list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endIdx</td><td>End index pointing to the child to end with in the children list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageIndex</td><td>Index of the swapchain image that is currently used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_v_e_scene_manager_8h_source.html">VESceneManager.h</a></li>
<li>VESceneManager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 27 2019 17:18:38 for Vienna Vulkan Engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
